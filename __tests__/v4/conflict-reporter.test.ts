/**
 * Conflict Reporter tests
 * Tests for generating Markdown and JSON conflict reports
 */

import type { CSSRuleConflict } from '../../src/v4/parser/conflict-resolver';
import type { CSSRuleOverride } from '../../src/v4/parser/css-rule-extractor';
import type { Theme } from '../../src/v4/types';

import { describe, expect, test } from 'bun:test';

import {
  generateJSONReport,
  generateMarkdownReport,
} from '../../src/v4/parser/conflict-reporter';

const ZERO_LENGTH = 0;

describe('Markdown Report Generation - Basic Structure', () => {
  test('generates header with metadata', () => {
    const conflicts: Array<CSSRuleConflict> = [];
    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
      version: '1.0.0',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('# CSS Rule Conflicts');
    expect(markdown).toContain('**Generated:** 2025-01-18T00:00:00Z');
    expect(markdown).toContain('**Source:** src/styles.css');
    expect(markdown).toContain('**Version:** 1.0.0');
  });

  test('generates header without version', () => {
    const conflicts: Array<CSSRuleConflict> = [];
    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('# CSS Rule Conflicts');
    expect(markdown).not.toContain('**Version:**');
  });

  test('generates summary section', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('## Summary');
    expect(markdown).toContain('- **Total conflicts:** 1');
    expect(markdown).toContain('- **Auto-resolved:** 1 (high confidence)');
    expect(markdown).toContain('- **Manual review needed:** 0');
  });

  test('generates footer with version', () => {
    const conflicts: Array<CSSRuleConflict> = [];
    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
      version: '1.0.0',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('_Generated by tailwind-resolver v1.0.0_');
  });

  test('generates footer without version', () => {
    const conflicts: Array<CSSRuleConflict> = [];
    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('_Generated by tailwind-resolver_');
    expect(markdown).not.toContain('v1.0.0');
  });
});

describe('Markdown Report - Auto-Resolved Section', () => {
  test('includes auto-resolved conflicts section', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('## Auto-Resolved Conflicts');
    expect(markdown).toContain('### Variant: `themeMono`');
    expect(markdown).toContain('#### `radius.lg`');
    expect(markdown).toContain('- **Location:** `.rounded-lg`');
    expect(markdown).toContain('- **Variable value:** `1rem`');
    expect(markdown).toContain('- **Rule value:** `0`');
    expect(markdown).toContain('- **Confidence:** High');
    expect(markdown).toContain('- **Status:** ✅ Applied');
  });

  test('skips auto-resolved section when empty', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Pseudo-class selectors',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).not.toContain('## Auto-Resolved Conflicts');
  });
});

describe('Markdown Report - Manual Review Section', () => {
  test('includes manual review section for low confidence conflicts', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg:hover',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg:hover',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Pseudo-class selectors',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('## Manual Review Required');
    expect(markdown).toContain('### Variant: `themeMono`');
    expect(markdown).toContain('#### `radius.lg`');
    expect(markdown).toContain('- **Location:** `.rounded-lg:hover`');
    expect(markdown).toContain('- **Confidence:** Low');
    expect(markdown).toContain('- **Reason:** Pseudo-class selectors');
    expect(markdown).toContain('- **Status:** ⚠️ Skipped');
    expect(markdown).toContain('- **Action:**');
  });

  test('includes media query info for media query conflicts', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Nested in media query',
          inMediaQuery: true,
          mediaQuery: '(min-width: 1024px)',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('- **Media Query:** `(min-width: 1024px)`');
  });

  test('skips manual review section when empty', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).not.toContain('## Manual Review Required');
  });
});

describe('Markdown Report - Recommendations Section', () => {
  test('includes recommendations for pseudo-class conflicts', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg:hover',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg:hover',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Pseudo-class selectors',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('## Recommendations');
    expect(markdown).toContain('1. **High-priority:** Review 1 conflict');
    expect(markdown).toContain('pseudo-class selectors');
  });

  test('includes recommendations for media query conflicts', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Nested in media query',
          inMediaQuery: true,
          mediaQuery: '(min-width: 1024px)',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('## Recommendations');
    expect(markdown).toContain('2. **Consider:**');
    expect(markdown).toContain('media-query-specific values');
  });

  test('includes recommendations for dynamic CSS values', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: 'calc(1rem + 2px)',
        ruleSelector: '.rounded-lg',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: 'calc(1rem + 2px)',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Dynamic CSS function values',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).toContain('## Recommendations');
    expect(markdown).toContain('3. **Review:**');
    expect(markdown).toContain('dynamic CSS values');
  });

  test('skips recommendations section when all conflicts are auto-resolved', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    expect(markdown).not.toContain('## Recommendations');
  });
});

describe('JSON Report Generation', () => {
  test('generates valid JSON with metadata', () => {
    const conflicts: Array<CSSRuleConflict> = [];
    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
      version: '1.0.0',
    };

    const json = generateJSONReport(conflicts, metadata);
    const parsed = JSON.parse(json);

    expect(parsed.generatedAt).toBe('2025-01-18T00:00:00Z');
    expect(parsed.source).toBe('src/styles.css');
    expect(parsed.version).toBe('1.0.0');
  });

  test('generates summary statistics', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'md',
        variableValue: '0.5rem',
        ruleValue: '0',
        ruleSelector: '.rounded-md:hover',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-md:hover',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Pseudo-class selectors',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const json = generateJSONReport(conflicts, metadata);
    const parsed = JSON.parse(json);

    const TOTAL_CONFLICTS = 2;
    expect(parsed.summary.total).toBe(TOTAL_CONFLICTS);
    expect(parsed.summary.autoResolved).toBe(1);
    expect(parsed.summary.manualReview).toBe(1);
  });

  test('includes conflict details', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const json = generateJSONReport(conflicts, metadata);
    const parsed = JSON.parse(json);

    expect(parsed.conflicts).toHaveLength(1);
    expect(parsed.conflicts[0]).toMatchObject({
      variantName: 'themeMono',
      themeProperty: 'radius',
      themeKey: 'lg',
      selector: '.rounded-lg',
      variableValue: '1rem',
      ruleValue: '0',
      confidence: 'high',
      canResolve: true,
      applied: true,
    });
  });

  test('includes media query info when present', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Nested in media query',
          inMediaQuery: true,
          mediaQuery: '(min-width: 1024px)',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const json = generateJSONReport(conflicts, metadata);
    const parsed = JSON.parse(json);

    expect(parsed.conflicts[0].inMediaQuery).toBe(true);
    expect(parsed.conflicts[0].mediaQuery).toBe('(min-width: 1024px)');
  });

  test('marks applied status correctly', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: true,
        confidence: 'high',
        cssRule: {} as CSSRuleOverride,
      },
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'md',
        variableValue: '0.5rem',
        ruleValue: '8px',
        ruleSelector: '.rounded-md',
        canResolve: true,
        confidence: 'medium',
        cssRule: {} as CSSRuleOverride,
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const json = generateJSONReport(conflicts, metadata);
    const parsed = JSON.parse(json);

    expect(parsed.conflicts[0].applied).toBe(true); // high confidence
    expect(parsed.conflicts[1].applied).toBe(false); // medium confidence
  });
});

describe('Edge Cases', () => {
  test('handles empty conflicts array', () => {
    const conflicts: Array<CSSRuleConflict> = [];
    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);
    const json = generateJSONReport(conflicts, metadata);

    expect(markdown).toContain('## Summary');
    expect(markdown).toContain('- **Total conflicts:** 0');

    const parsed = JSON.parse(json);
    expect(parsed.summary.total).toBe(0);
    expect(parsed.conflicts).toHaveLength(ZERO_LENGTH);
  });

  test('handles conflicts without reason', () => {
    const conflicts: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg',
        canResolve: false,
        confidence: 'medium',
        cssRule: {
          selector: '.rounded-lg',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'simple',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(conflicts, metadata);

    // Should not crash, reason line should be skipped
    expect(markdown).toContain('## Manual Review Required');
    expect(markdown).not.toContain('- **Reason:**');
  });

  test('handles plural vs singular in recommendations', () => {
    const singleConflict: Array<CSSRuleConflict> = [
      {
        variantName: 'themeMono',
        themeProperty: 'radius' as keyof Theme,
        themeKey: 'lg',
        variableValue: '1rem',
        ruleValue: '0',
        ruleSelector: '.rounded-lg:hover',
        canResolve: false,
        confidence: 'low',
        cssRule: {
          selector: '.rounded-lg:hover',
          property: 'border-radius',
          value: '0',
          variantName: 'themeMono',
          originalSelector: '.theme-mono',
          complexity: 'complex',
          reason: 'Pseudo-class selectors',
        },
      },
    ];

    const metadata = {
      generatedAt: '2025-01-18T00:00:00Z',
      source: 'src/styles.css',
    };

    const markdown = generateMarkdownReport(singleConflict, metadata);

    expect(markdown).toContain('Review 1 conflict'); // Singular
  });
});
