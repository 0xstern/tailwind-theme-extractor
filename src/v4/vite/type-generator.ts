/**
 * Generates TypeScript type definitions from resolved theme
 */

import type { ParseResult, Theme } from '../types';

const JSON_INDENT_SPACES = 2;

/**
 * Property configurations for theme type generation
 * Single source of truth for all theme properties and their type generators
 */
interface PropertyConfig {
  key: keyof Theme;
  generator: (value: Record<string, unknown>) => string;
}

/**
 * Centralized property configurations used across type generation
 */
const THEME_PROPERTY_CONFIGS: Array<PropertyConfig> = [
  {
    key: 'colors',
    generator: (v) => generateColorTypes(v as Theme['colors']),
  },
  {
    key: 'fontSize',
    generator: (v) => generateFontSizeTypes(v as Theme['fontSize']),
  },
  {
    key: 'fonts',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'fontWeight',
    generator: (v) =>
      generateMixedRecordType(v as Record<string, string | number>),
  },
  {
    key: 'spacing',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'breakpoints',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'containers',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'radius',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'shadows',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'insetShadows',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'dropShadows',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'textShadows',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'blur',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'perspective',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'aspect',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'ease',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'animations',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'tracking',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'leading',
    generator: (v) =>
      generateMixedRecordType(v as Record<string, string | number>),
  },
  {
    key: 'defaults',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
  {
    key: 'keyframes',
    generator: (v) => generateRecordType(v as Record<string, string>),
  },
] as const;

/**
 * Escapes a string value for use in TypeScript string literals
 *
 * @param value - The string to escape
 * @returns Escaped string safe for use in TypeScript code
 */
function escapeStringLiteral(value: string): string {
  // Early return if no escaping needed (most common case for CSS values)
  if (!/[\\'\n]/.test(value)) {
    return value;
  }

  return value
    .replace(/\\/g, '\\\\') // Escape backslashes first
    .replace(/'/g, "\\'") // Escape single quotes
    .replace(/\n/g, '\\n'); // Escape newlines
}

/**
 * Generate TypeScript type declarations file (.d.ts)
 * This file is always generated and contains all type definitions
 *
 * @param result - The parsed theme result
 * @param interfaceName - Name of the generated interface
 * @param sourceFile - Path to the source CSS file for documentation
 * @returns TypeScript type declaration string
 */
export function generateTypeDeclarations(
  result: ParseResult,
  interfaceName: string = 'GeneratedTheme',
  sourceFile?: string,
): string {
  const typeDefinitions: Array<string> = [];

  // Strong warning header
  typeDefinitions.push('/**');
  typeDefinitions.push(' * ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY');
  typeDefinitions.push(' *');
  typeDefinitions.push(
    ' * This file is automatically generated by tailwind-theme-resolver.',
  );
  typeDefinitions.push(
    ' * Any manual changes will be overwritten on the next build.',
  );
  typeDefinitions.push(' *');
  typeDefinitions.push(` * Generated at: ${new Date().toISOString()}`);
  typeDefinitions.push(' *');
  if (sourceFile !== undefined) {
    typeDefinitions.push(` * To modify: Edit ${sourceFile}`);
  } else {
    typeDefinitions.push(' * To modify: Edit your theme CSS file');
  }
  typeDefinitions.push(
    ' * To regenerate: Save your theme CSS file or restart the dev server',
  );
  typeDefinitions.push(' */');
  typeDefinitions.push('');
  typeDefinitions.push('/* eslint-disable */');
  typeDefinitions.push('// @ts-nocheck');
  typeDefinitions.push('// @generated');
  typeDefinitions.push('');

  // Main theme interface - use centralized property configs
  typeDefinitions.push(`export interface ${interfaceName} {`);
  for (const { key, generator } of THEME_PROPERTY_CONFIGS) {
    const value = result.theme[key] as Record<string, unknown>;
    const typeString = generator(value);
    typeDefinitions.push(`  ${key}: ${typeString};`);
  }
  typeDefinitions.push('}');
  typeDefinitions.push('');

  // No need for variant interfaces - variants are just themes

  // Module augmentation to override library types
  // We augment the Theme interface to be exactly our generated theme type
  typeDefinitions.push("declare module 'tailwind-theme-resolver' {");
  typeDefinitions.push(`  export interface Theme extends ${interfaceName} {}`);
  typeDefinitions.push('}');
  typeDefinitions.push('');

  // Type declarations for runtime exports
  typeDefinitions.push('// Runtime value declarations');
  typeDefinitions.push(`export declare const base: ${interfaceName};`);
  typeDefinitions.push('export default base;');
  typeDefinitions.push('');

  // Type declarations for variants
  if (Object.keys(result.variants).length > 0) {
    for (const [variantName, variantData] of Object.entries(result.variants)) {
      // Generate inline type for this variant based on its actual structure
      const variantType = generateThemeTypeInline(variantData.theme);

      // Sanitize variant name for JavaScript export
      const safeExportName = toSafeIdentifier(variantName);

      typeDefinitions.push(
        `export declare const ${safeExportName}: ${variantType};`,
      );
    }
    typeDefinitions.push('');

    // Type declaration for selectors
    typeDefinitions.push('/**');
    typeDefinitions.push(' * CSS selectors for each theme variant');
    typeDefinitions.push(' */');

    // Generate selectors type
    const selectorTypes = Object.keys(result.variants)
      .map((variantName) => {
        const safeExportName = toSafeIdentifier(variantName);
        return `${safeExportName}: string`;
      })
      .join('; ');

    typeDefinitions.push(
      `export declare const selectors: { ${selectorTypes} };`,
    );
    typeDefinitions.push('');
  }

  return typeDefinitions.join('\n');
}

function generateMixedRecordType(obj: Record<string, string | number>): string {
  const entries = Object.entries(obj);

  if (entries.length === 0) {
    return '{}';
  }

  const props = entries
    .map(([key, value]) => {
      const safeKey = isValidIdentifier(key) ? key : `'${key}'`;
      if (typeof value === 'number') {
        return `${safeKey}: ${value}`;
      }
      return `${safeKey}: '${value}'`;
    })
    .join(';\n  ');

  return `{\n  ${props}\n}`;
}

function generateColorTypes(colors: Theme['colors']): string {
  const entries = Object.entries(colors);

  if (entries.length === 0) {
    return '{}';
  }

  const colorProps = entries
    .map(([key, value]) => {
      const safeKey = isValidIdentifier(key) ? key : `'${key}'`;

      if (typeof value === 'string') {
        return `${safeKey}: '${value}'`;
      }

      // Color scale object
      const scaleEntries = Object.entries(value)
        .map(([variant, color]) => {
          const safeVariant = isValidIdentifier(variant)
            ? variant
            : `'${variant}'`;
          return `${safeVariant}: '${color}'`;
        })
        .join('; ');

      return `${safeKey}: { ${scaleEntries} }`;
    })
    .join(';\n  ');

  return `{\n  ${colorProps}\n}`;
}

function generateFontSizeTypes(fontSize: Theme['fontSize']): string {
  const entries = Object.entries(fontSize);

  if (entries.length === 0) {
    return '{}';
  }

  const fontSizeProps = entries
    .map(([key, config]) => {
      const safeKey = isValidIdentifier(key) ? key : `'${key}'`;

      if (config.lineHeight !== undefined) {
        return `${safeKey}: { size: '${config.size}'; lineHeight: '${config.lineHeight}' }`;
      }

      return `${safeKey}: { size: '${config.size}'; lineHeight?: undefined }`;
    })
    .join(';\n  ');

  return `{\n  ${fontSizeProps}\n}`;
}

function generateRecordType(obj: Record<string, string>): string {
  const entries = Object.entries(obj);

  if (entries.length === 0) {
    return '{}';
  }

  const props = entries
    .map(([key, value]) => {
      const safeKey = isValidIdentifier(key) ? key : `'${key}'`;
      return `${safeKey}: '${escapeStringLiteral(value)}'`;
    })
    .join(';\n  ');

  return `{\n  ${props}\n}`;
}

function isValidIdentifier(str: string): boolean {
  // Check if string is a valid JavaScript identifier
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str);
}

/**
 * Converts a string to a safe JavaScript identifier
 * Handles kebab-case by converting to camelCase
 * Ensures the result is a valid JavaScript identifier
 *
 * @param str - The string to convert
 * @returns A safe JavaScript identifier
 */
function toSafeIdentifier(str: string): string {
  // If already valid, return as-is
  if (isValidIdentifier(str)) {
    return str;
  }

  // Convert kebab-case to camelCase
  const camelCase = str.replace(/-([a-z])/g, (_, letter: string) =>
    letter.toUpperCase(),
  );

  // If now valid, return
  if (isValidIdentifier(camelCase)) {
    return camelCase;
  }

  // Handle edge cases: starts with number, contains special chars, etc.
  // Prefix with underscore if starts with number
  let safe = camelCase.replace(/^(\d)/, '_$1');

  // Replace any remaining invalid characters with underscore
  safe = safe.replace(/[^a-zA-Z0-9_$]/g, '_');

  return safe;
}

/**
 * Checks if a theme property has any keys
 *
 * @param obj - The object to check
 * @returns True if the object has any keys, false otherwise
 */
function hasKeys(obj: Record<string, unknown> | undefined): boolean {
  return obj !== undefined && Object.keys(obj).length > 0;
}

/**
 * Removes empty objects and arrays from a theme object
 * Returns a new object with only non-empty properties
 *
 * @param theme - The theme object to clean
 * @returns Theme object with empty properties removed
 */
function removeEmptyProperties(theme: Theme): Partial<Theme> {
  const cleaned: Partial<Theme> = {};

  // Use centralized property configs
  for (const { key } of THEME_PROPERTY_CONFIGS) {
    const value = theme[key];
    if (hasKeys(value as Record<string, unknown>)) {
      // Type assertion needed due to TypeScript's union type limitations
      (cleaned as Record<string, unknown>)[key] = value;
    }
  }

  return cleaned;
}

/**
 * Generates an inline type definition for a theme object
 * Only includes properties that are actually present in the theme
 *
 * @param theme - The theme object to generate a type for
 * @returns Inline TypeScript type definition
 */
function generateThemeTypeInline(theme: Theme): string {
  const parts: Array<string> = [];

  // Use centralized property configs, but skip defaults and keyframes for variants
  const variantPropertyConfigs = THEME_PROPERTY_CONFIGS.filter(
    ({ key }) => key !== 'defaults' && key !== 'keyframes',
  );

  // Only include non-empty properties
  for (const { key, generator } of variantPropertyConfigs) {
    const value = theme[key] as Record<string, unknown>;
    if (hasKeys(value)) {
      parts.push(`${key}: ${generator(value)}`);
    }
  }

  if (parts.length === 0) {
    return '{}';
  }

  return `{\n  ${parts.join(';\n  ')}\n}`;
}

/**
 * Generate TypeScript runtime file (.ts)
 * This file imports types from the .d.ts file and exports runtime values
 *
 * @param result - The parsed theme result
 * @param _interfaceName - Name of the generated interface (unused)
 * @returns TypeScript runtime file string
 */
export function generateRuntimeFile(
  result: ParseResult,
  _interfaceName: string = 'GeneratedTheme',
): string {
  const lines: Array<string> = [];

  // Header
  lines.push('/**');
  lines.push(' * ⚠️ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY');
  lines.push(' *');
  lines.push(
    ' * This file is automatically generated by tailwind-theme-resolver.',
  );
  lines.push(' * Any manual changes will be overwritten on the next build.');
  lines.push(' *');
  lines.push(` * Generated at: ${new Date().toISOString()}`);
  lines.push(' *');
  lines.push(' * To modify: Edit your theme CSS file');
  lines.push(
    ' * To regenerate: Save your theme CSS file or restart the dev server',
  );
  lines.push(' */');
  lines.push('');
  lines.push('/* eslint-disable */');
  lines.push('// @ts-nocheck');
  lines.push('// @generated');
  lines.push('');

  // Export base theme with as const for type inference
  lines.push(
    `export const base = ${JSON.stringify(result.theme, null, JSON_INDENT_SPACES)} as const;`,
  );
  lines.push('');
  lines.push('export default base;');
  lines.push('');

  // Export variants
  if (Object.keys(result.variants).length > 0) {
    for (const [variantName, variantData] of Object.entries(result.variants)) {
      // Remove empty properties from the runtime object
      const cleanedTheme = removeEmptyProperties(variantData.theme);

      // Sanitize variant name for JavaScript export
      const safeExportName = toSafeIdentifier(variantName);

      lines.push(
        `export const ${safeExportName} = ${JSON.stringify(cleanedTheme, null, JSON_INDENT_SPACES)} as const;`,
      );
      lines.push('');
    }

    // Export selectors
    lines.push('/**');
    lines.push(' * CSS selectors for each theme variant');
    lines.push(' */');
    lines.push('export const selectors = {');

    const selectorEntries = Object.entries(result.variants)
      .map(([variantName, variantData]) => {
        const safeExportName = toSafeIdentifier(variantName);
        return `  ${safeExportName}: '${escapeStringLiteral(variantData.selector)}'`;
      })
      .join(',\n');

    lines.push(selectorEntries);
    lines.push('} as const;');
    lines.push('');
  }

  return lines.join('\n');
}
